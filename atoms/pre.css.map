{"mappings":"AAAA,IAEA,wBAAmB,CAAnB,6CAAmB,CAAnB,oBAAmB,CAAnB,YAAmB,CAAnB,aAAmB,CAAnB,aAAA","sources":["node_modules/tailwindcss/lib/lib/substituteClassApplyAtRules.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = substituteClassApplyAtRules;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _didyoumean = _interopRequireDefault(require(\"didyoumean\"));\n\nvar _substituteTailwindAtRules = _interopRequireDefault(require(\"./substituteTailwindAtRules\"));\n\nvar _evaluateTailwindFunctions = _interopRequireDefault(require(\"./evaluateTailwindFunctions\"));\n\nvar _substituteVariantsAtRules = _interopRequireDefault(require(\"./substituteVariantsAtRules\"));\n\nvar _substituteResponsiveAtRules = _interopRequireDefault(require(\"./substituteResponsiveAtRules\"));\n\nvar _convertLayerAtRulesToControlComments = _interopRequireDefault(require(\"./convertLayerAtRulesToControlComments\"));\n\nvar _substituteScreenAtRules = _interopRequireDefault(require(\"./substituteScreenAtRules\"));\n\nvar _prefixSelector = _interopRequireDefault(require(\"../util/prefixSelector\"));\n\nvar _useMemo = require(\"../util/useMemo\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction hasAtRule(css, atRule, condition) {\n  let found = false;\n  css.walkAtRules(atRule, condition === undefined ? () => {\n    found = true;\n    return false;\n  } : node => {\n    if (condition(node)) {\n      found = true;\n      return false;\n    }\n  });\n  return found;\n}\n\nfunction cloneWithoutChildren(node) {\n  if (node.type === 'atrule') {\n    return _postcss.default.atRule({\n      name: node.name,\n      params: node.params\n    });\n  }\n\n  if (node.type === 'rule') {\n    return _postcss.default.rule({\n      name: node.name,\n      selectors: node.selectors\n    });\n  }\n\n  const clone = node.clone();\n  clone.removeAll();\n  return clone;\n}\n\nconst tailwindApplyPlaceholder = _postcssSelectorParser.default.attribute({\n  attribute: '__TAILWIND-APPLY-PLACEHOLDER__'\n});\n\nfunction generateRulesFromApply({\n  rule,\n  utilityName: className,\n  classPosition\n}, replaceWiths) {\n  const parser = (0, _postcssSelectorParser.default)(selectors => {\n    let i = 0;\n    selectors.walkClasses(c => {\n      if (classPosition === i++ && c.value === className) {\n        c.replaceWith(tailwindApplyPlaceholder);\n      }\n    });\n  });\n\n  const processedSelectors = _lodash.default.flatMap(rule.selectors, selector => {\n    // You could argue we should make this replacement at the AST level, but if we believe\n    // the placeholder string is safe from collisions then it is safe to do this is a simple\n    // string replacement, and much, much faster.\n    return replaceWiths.map(replaceWith => parser.processSync(selector).replace('[__TAILWIND-APPLY-PLACEHOLDER__]', replaceWith));\n  });\n\n  const cloned = rule.clone();\n  let current = cloned;\n  let parent = rule.parent;\n\n  while (parent && parent.type !== 'root') {\n    const parentClone = cloneWithoutChildren(parent);\n    parentClone.append(current);\n    current.parent = parentClone;\n    current = parentClone;\n    parent = parent.parent;\n  }\n\n  cloned.selectors = processedSelectors;\n  return current;\n}\n\nconst extractUtilityNamesParser = (0, _postcssSelectorParser.default)(selectors => {\n  let classes = [];\n  selectors.walkClasses(c => classes.push(c.value));\n  return classes;\n});\nconst extractUtilityNames = (0, _useMemo.useMemo)(selector => extractUtilityNamesParser.transformSync(selector), selector => selector);\nconst cloneRuleWithParent = (0, _useMemo.useMemo)(rule => rule.clone({\n  parent: rule.parent\n}), rule => rule);\n\nfunction buildCssUtilityMap(css, startIndex) {\n  let index = startIndex;\n  const utilityMap = {};\n\n  function handle(getRule, rule) {\n    const utilityNames = extractUtilityNames(rule.selector);\n    utilityNames.forEach((utilityName, i) => {\n      if (utilityMap[utilityName] === undefined) {\n        utilityMap[utilityName] = [];\n      }\n\n      utilityMap[utilityName].push({\n        index,\n        utilityName,\n        classPosition: i,\n        ...getRule(rule)\n      });\n      index++;\n    });\n  } // This is the end user's css. This might contain rules that we want to\n  // apply. We want immediate copies of everything in case that we have user\n  // defined classes that are recursively applied. Down below we are modifying\n  // the rules directly. We could do a better solution where we keep track of a\n  // dependency tree, but that is a bit more complex. Might revisit later,\n  // we'll see how this turns out!\n\n\n  css.walkRules(handle.bind(null, rule => ({\n    rule: cloneRuleWithParent(rule)\n  })));\n  return utilityMap;\n}\n\nconst buildLookupTreeUtilityMap = (0, _useMemo.useMemo)(lookupTree => {\n  let index = 0;\n  const utilityMap = {};\n\n  function handle(getRule, rule) {\n    const utilityNames = extractUtilityNames(rule.selector);\n    utilityNames.forEach((utilityName, i) => {\n      if (utilityMap[utilityName] === undefined) {\n        utilityMap[utilityName] = [];\n      }\n\n      utilityMap[utilityName].push({\n        index,\n        utilityName,\n        classPosition: i,\n        ...getRule(rule)\n      });\n      index++;\n    });\n  } // Lookup tree is the big lookup tree, making the rule lazy allows us to save\n  // some memory because we don't need everything.\n\n\n  lookupTree.walkRules(handle.bind(null, rule => ({\n    get rule() {\n      return cloneRuleWithParent(rule);\n    }\n\n  })));\n  return utilityMap;\n}, tree => tree);\n\nfunction mergeAdjacentRules(initialRule, rulesToInsert) {\n  let previousRule = initialRule;\n  rulesToInsert.forEach(toInsert => {\n    if (toInsert.type === 'rule' && previousRule.type === 'rule' && toInsert.selector === previousRule.selector) {\n      previousRule.append(toInsert.nodes);\n    } else if (toInsert.type === 'atrule' && previousRule.type === 'atrule' && toInsert.params === previousRule.params) {\n      const merged = mergeAdjacentRules(previousRule.nodes[previousRule.nodes.length - 1], toInsert.nodes);\n      previousRule.append(merged);\n    } else {\n      previousRule = toInsert;\n    }\n\n    toInsert.walk(n => {\n      if (n.nodes && n.nodes.length === 0) {\n        n.remove();\n      }\n    });\n  });\n  return rulesToInsert.filter(r => r.nodes.length > 0);\n}\n\nfunction makeExtractUtilityRules(css, lookupTree, config) {\n  const lookupTreeUtilityMap = buildLookupTreeUtilityMap(lookupTree);\n  const lookupTreeUtilityMapKeys = Object.keys(lookupTreeUtilityMap);\n  const utilityMap = buildCssUtilityMap(css, lookupTreeUtilityMapKeys.length);\n\n  function getUtility(utilityName) {\n    const utility = [];\n\n    if (lookupTreeUtilityMap[utilityName]) {\n      utility.push(...lookupTreeUtilityMap[utilityName]);\n    }\n\n    if (utilityMap[utilityName]) {\n      utility.push(...utilityMap[utilityName]);\n    }\n\n    if (utility.length > 0) return utility;\n  }\n\n  return function extractUtilityRules(utilityNames, rule) {\n    const combined = [];\n    utilityNames.forEach(utilityName => {\n      const utility = getUtility(utilityName);\n\n      if (utility === undefined) {\n        // Look for prefixed utility in case the user has goofed\n        const prefixedUtilityName = (0, _prefixSelector.default)(config.prefix, `.${utilityName}`).slice(1);\n        const prefixedUtility = getUtility(prefixedUtilityName);\n\n        if (prefixedUtility !== undefined) {\n          throw rule.error(`The \\`${utilityName}\\` class does not exist, but \\`${prefixedUtilityName}\\` does. Did you forget the prefix?`);\n        }\n\n        const suggestedClass = (0, _didyoumean.default)(utilityName, Object.keys(utilityMap).concat(lookupTreeUtilityMapKeys));\n        const suggestionMessage = suggestedClass ? `, but \\`${suggestedClass}\\` does` : '';\n        throw rule.error(`The \\`${utilityName}\\` class does not exist${suggestionMessage}. If you're sure that \\`${utilityName}\\` exists, make sure that any \\`@import\\` statements are being properly processed before Tailwind CSS sees your CSS, as \\`@apply\\` can only be used for classes in the same CSS tree.`, {\n          word: utilityName\n        });\n      }\n\n      combined.push(...utility);\n    });\n    return combined.sort((a, b) => a.index - b.index);\n  };\n}\n\nfunction findParent(rule, predicate) {\n  let parent = rule.parent;\n\n  while (parent) {\n    if (predicate(parent)) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  }\n\n  throw new Error('No parent could be found');\n}\n\nfunction processApplyAtRules(css, lookupTree, config) {\n  const extractUtilityRules = makeExtractUtilityRules(css, lookupTree, config);\n\n  do {\n    css.walkAtRules('apply', applyRule => {\n      const parent = applyRule.parent; // Direct parent\n\n      const nearestParentRule = findParent(applyRule, r => r.type === 'rule');\n      const currentUtilityNames = extractUtilityNames(nearestParentRule.selector);\n\n      const [importantEntries, applyUtilityNames, important = importantEntries.length > 0] = _lodash.default.partition(applyRule.params.split(/[\\s\\t\\n]+/g), n => n === '!important');\n\n      if (_lodash.default.intersection(applyUtilityNames, currentUtilityNames).length > 0) {\n        const currentUtilityName = _lodash.default.intersection(applyUtilityNames, currentUtilityNames)[0];\n\n        throw parent.error(`You cannot \\`@apply\\` the \\`${currentUtilityName}\\` utility here because it creates a circular dependency.`);\n      } // Extract any post-apply declarations and re-insert them after apply rules\n\n\n      const afterRule = parent.clone({\n        raws: {}\n      });\n      afterRule.nodes = afterRule.nodes.slice(parent.index(applyRule) + 1);\n      parent.nodes = parent.nodes.slice(0, parent.index(applyRule) + 1); // Sort applys to match CSS source order\n\n      const applys = extractUtilityRules(applyUtilityNames, applyRule); // Get new rules with the utility portion of the selector replaced with the new selector\n\n      const rulesToInsert = [];\n      applys.forEach(nearestParentRule === parent ? util => rulesToInsert.push(generateRulesFromApply(util, parent.selectors)) : util => util.rule.nodes.forEach(n => afterRule.append(n.clone())));\n      rulesToInsert.forEach(rule => {\n        if (rule.type === 'atrule') {\n          rule.walkRules(rule => {\n            rule.__tailwind = { ...rule.__tailwind,\n              important\n            };\n          });\n        } else {\n          rule.__tailwind = { ...rule.__tailwind,\n            important\n          };\n        }\n      });\n\n      const {\n        nodes\n      } = _lodash.default.tap(_postcss.default.root({\n        nodes: rulesToInsert\n      }), root => {\n        root.walkDecls(d => {\n          d.important = important;\n        });\n      });\n\n      const mergedRules = mergeAdjacentRules(nearestParentRule, [...nodes, afterRule]);\n      applyRule.remove();\n      parent.after(mergedRules); // If the base rule has nothing in it (all applys were pseudo or responsive variants),\n      // remove the rule fuggit.\n\n      if (parent.nodes.length === 0) {\n        parent.remove();\n      }\n    }); // We already know that we have at least 1 @apply rule. Otherwise this\n    // function would not have been called. Therefore we can execute this code\n    // at least once. This also means that in the best case scenario we only\n    // call this 2 times, instead of 3 times.\n    // 1st time -> before we call this function\n    // 2nd time -> when we check if we have to do this loop again (because do {} while (check))\n    // .. instead of\n    // 1st time -> before we call this function\n    // 2nd time -> when we check the first time (because while (check) do {})\n    // 3rd time -> when we re-check to see if we should do this loop again\n  } while (hasAtRule(css, 'apply'));\n\n  return css;\n}\n\nlet defaultTailwindTree = new Map();\n\nfunction substituteClassApplyAtRules(config, getProcessedPlugins, configChanged) {\n  return function (css) {\n    // We can stop already when we don't have any @apply rules. Vue users: you're welcome!\n    if (!hasAtRule(css, 'apply')) {\n      return css;\n    }\n\n    let requiredTailwindAtRules = ['base', 'components', 'utilities'];\n\n    if (hasAtRule(css, 'tailwind', node => {\n      let idx = requiredTailwindAtRules.indexOf(node.params);\n      if (idx !== -1) requiredTailwindAtRules.splice(idx, 1);\n      if (requiredTailwindAtRules.length <= 0) return true;\n      return false;\n    })) {\n      // Tree already contains all the at rules (requiredTailwindAtRules)\n      return processApplyAtRules(css, _postcss.default.root(), config);\n    }\n\n    let lookupKey = requiredTailwindAtRules.join(','); // We mutated the `requiredTailwindAtRules`, but when we hit this point in\n    // time, it means that we don't have all the atrules. The missing atrules\n    // are listed inside the requiredTailwindAtRules, which we can use to fill\n    // in the missing pieces.\n    //\n    // Important for <style> blocks in Vue components.\n\n    const generateLookupTree = configChanged || !defaultTailwindTree.has(lookupKey) ? () => {\n      return (0, _postcss.default)([(0, _substituteTailwindAtRules.default)(config, getProcessedPlugins()), (0, _evaluateTailwindFunctions.default)({\n        tailwindConfig: config\n      }), (0, _substituteVariantsAtRules.default)(config, getProcessedPlugins()), (0, _substituteResponsiveAtRules.default)(config), (0, _convertLayerAtRulesToControlComments.default)(config), (0, _substituteScreenAtRules.default)({\n        tailwindConfig: config\n      })]).process(requiredTailwindAtRules.map(rule => `@tailwind ${rule};`).join('\\n'), {\n        from: __filename\n      }).then(result => {\n        defaultTailwindTree.set(lookupKey, result);\n        return result;\n      });\n    } : () => Promise.resolve(defaultTailwindTree.get(lookupKey));\n    return generateLookupTree().then(result => {\n      return processApplyAtRules(css, result.root, config);\n    });\n  };\n}"],"names":[],"version":3,"file":"pre.css.map"}